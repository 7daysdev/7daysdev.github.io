<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Analytics & Search</title>
    <link rel="stylesheet" href="styles.css"> 
    <link rel="stylesheet" href="analytics-styles.css"> 
    
</head>

<body>
    <div class="container">
        <h1>Card Analytics & Search</h1>

        <div class="header-actions">
            <a href="card-index.html" class="btn">‚Üê Back to Card List</a>
        </div>
        
        <div class="info-block">
            <p>
                Use the search bar to find cards by **Name**, **ID**, or keywords in the **Level 1 Ability Text**. 
                Click multiple **Type** buttons below to narrow the results using **AND** logic (a card must have ALL selected types). Click table headers to **sort** the data.
            </p>
        </div>
        
        <div class="filter-controls">
            <input type="text" id="searchInput" placeholder="Search Card Name, ID, or Ability Text...">
            
            <button id="applyFiltersBtn" class="btn">Apply Filters</button>
        </div>
        
        <div id="typeFilterContainer" class="type-filter-container">
            </div>

        <div id="analytics-results-container">
            <p class="loading">Loading card data...</p>
        </div>
    </div>
    
<script>
    let allCardsData = [];
    let currentFilteredCards = [];
    let sortDirection = 'asc';
    let lastSortKey = null;

    const resultsContainer = document.getElementById('analytics-results-container');
    const typeFilterContainer = document.getElementById('typeFilterContainer'); // Reference to the new container
    const searchInput = document.getElementById('searchInput');
    const applyButton = document.getElementById('applyFiltersBtn');

    // --- Data Fetching (Unchanged) ---
    async function fetchCards() {
        try {
            const response = await fetch('./card.json'); 
            const data = await response.json();
            allCardsData = data.cards || data; 
            
            populateTypeFilters(allCardsData);
            filterAndRenderCards(); 

        } catch (error) {
            console.error('Failed to load card data:', error);
            resultsContainer.innerHTML = '<p class="error">Error loading card data. Make sure card.json exists and is valid.</p>';
        }
    }

    // --- Filter Population (Updated to create buttons) ---
    function populateTypeFilters(cards) {
        const uniqueTypes = new Set();
        cards.forEach(card => {
            if (Array.isArray(card.type)) {
                card.type.forEach(t => uniqueTypes.add(t));
            } else if (typeof card.type === 'string') {
                card.type.split(/\s*\|\s*|\s+/).forEach(t => {
                    if (t.trim()) uniqueTypes.add(t.trim());
                });
            }
        });

        // Clear existing content
        typeFilterContainer.innerHTML = ''; 
        
        // Add all unique types as buttons
        Array.from(uniqueTypes).sort().forEach(type => {
            const button = document.createElement('button');
            button.className = 'type-filter-btn';
            button.textContent = type;
            button.dataset.type = type; // Store the type value
            button.type = 'button'; // Prevent accidental form submission
            
            // Add click listener to toggle the active state
            button.addEventListener('click', function() {
                this.classList.toggle('active');
            });
            
            typeFilterContainer.appendChild(button);
        });
    }

    // --- Filter and Search Logic (Updated to read button states) ---
    function filterAndRenderCards() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        
        // üåü NEW: Get an array of all selected type values from active buttons üåü
        const selectedTypes = Array.from(typeFilterContainer.querySelectorAll('.type-filter-btn.active'))
                                 .map(button => button.dataset.type);

        currentFilteredCards = allCardsData.filter(card => {
            // 1. Type Filter Check
            const cardTypes = Array.isArray(card.type) ? card.type : (typeof card.type === 'string' ? card.type.split(/\s*\|\s*|\s+/).map(t => t.trim()).filter(t => t) : []);
            
            let matchesType = true;
            
            if (selectedTypes.length > 0) {
                // Multi-type (AND) filter: Card must include ALL selected types
                matchesType = selectedTypes.every(type => cardTypes.includes(type));
            } 

            if (!matchesType) {
                return false;
            }

            // 2. Text Search Check (Unchanged)
            if (!searchTerm) {
                return true; 
            }

            const cardName = card.card_name.toLowerCase();
            const cardId = card.card_id.toLowerCase();
            let abilityText = '';
            
            if (card.abilities && card.abilities.level_1 && card.abilities.level_1.ability_text) {
                abilityText = card.abilities.level_1.ability_text.toLowerCase();
            }

            return cardName.includes(searchTerm) || 
                   cardId.includes(searchTerm) || 
                   abilityText.includes(searchTerm);
        });

        renderCardsTable(currentFilteredCards);
    }

    // --- Remaining Functions (renderCardsTable, sortTable, Event Listeners) are unchanged in logic ---
    function renderCardsTable(cards) {
        if (cards.length === 0) {
            resultsContainer.innerHTML = '<p class="error">No cards match the current filters.</p>';
            return;
        }

        let tableHTML = `
            <table class="analytics-table">
                <thead>
                    <tr>
                        <th data-sort-key="card_name" class="${lastSortKey === 'card_name' ? 'sorted-' + sortDirection : ''}">Name</th>
                        <th data-sort-key="card_id" class="${lastSortKey === 'card_id' ? 'sorted-' + sortDirection : ''}">ID</th>
                        <th data-sort-key="rarity" class="${lastSortKey === 'rarity' ? 'sorted-' + sortDirection : ''}">Rarity</th>
                        <th data-sort-key="type" class="${lastSortKey === 'type' ? 'sorted-' + sortDirection : ''}">Types</th>
                        <th data-sort-key="activation_method" class="${lastSortKey === 'activation_method' ? 'sorted-' + sortDirection : ''}">Activation</th>
                        <th data-sort-key="ability_text" class="${lastSortKey === 'ability_text' ? 'sorted-' + sortDirection : ''}">Level 1 Ability</th>
                    </tr>
                </thead>
                <tbody>
        `;

        cards.forEach(card => {
            const rarityClass = card.rarity ? `rarity-${card.rarity.replace(/\s/g, '')}` : 'rarity-unknown';
            const typeDisplay = Array.isArray(card.type) ? card.type.join(' | ') : (card.type || 'N/A');
            
            let abilityText = 'N/A';
            if (card.abilities && card.abilities.level_1 && card.abilities.level_1.ability_text) {
                abilityText = card.abilities.level_1.ability_text;
            }
            
            tableHTML += `
                <tr data-card-id="${card.card_id}">
                    <td>${card.card_name}</td>
                    <td>${card.card_id}</td>
                    <td class="${rarityClass}">${card.rarity || 'N/A'}</td>
                    <td>${typeDisplay}</td>
                    <td>${card.activation_method || 'N/A'}</td>
                    <td>${abilityText}</td>
                </tr>
            `;
        });

        tableHTML += '</tbody></table>';
        resultsContainer.innerHTML = tableHTML;
    }

    function sortTable(key) {
        if (lastSortKey === key) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            sortDirection = 'asc';
            lastSortKey = key;
        }

        currentFilteredCards.sort((a, b) => {
            let valA, valB;

            if (key === 'ability_text') {
                valA = (a.abilities?.level_1?.ability_text || '').toLowerCase();
                valB = (b.abilities?.level_1?.ability_text || '').toLowerCase();
            } else if (key === 'type') {
                valA = (Array.isArray(a.type) ? a.type.join(' ') : (a.type || '')).toLowerCase();
                valB = (Array.isArray(b.type) ? b.type.join(' ') : (b.type || '')).toLowerCase();
            } else {
                valA = (a[key] || '').toString().toLowerCase();
                valB = (b[key] || '').toString().toLowerCase();
            }

            if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
            if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
            return 0;
        });

        renderCardsTable(currentFilteredCards);
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchCards(); 
        
        // Use the Apply button for filtering
        applyButton.addEventListener('click', filterAndRenderCards);
        
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                filterAndRenderCards();
            }
        });
        
        resultsContainer.addEventListener('click', function(e) {
            const th = e.target.closest('th');
            if (th && th.dataset.sortKey) {
                const sortKey = th.dataset.sortKey;
                sortTable(sortKey);
            }
        });
    });

</script>
</body>

</html>