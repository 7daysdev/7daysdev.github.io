<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Analytics & Search</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="analytics-styles.css">

</head>

<body>
    <div class="container">
        <h1>Card Analytics & Search</h1>

        <div class="header-actions">
            <a href="analytics-charts.html" class="btn btn-secondary">üìä View Summary Charts</a>
            <a href="cards-index.html" class="btn">‚Üê Back to Cards Index (Grid View)</a>
        </div>

        <div class="filter-controls">
            <div class="search-group">
                <input type="text" id="searchInput" placeholder="Search Card Name, ID, or Ability Text...">
                <button id="clearFiltersBtn" class="btn btn-secondary">Clear Filters</button>
                <button id="exportDataBtn" class="btn btn-primary">Export Filtered Data üìÑ</button>
            </div>
        </div>

        <textarea id="exportOutput" rows="10" cols="80"
            style="width: 100%; display: none; margin-top: 15px; font-family: monospace;"></textarea>

    </div>

    <div id="typeFilterContainer" class="type-filter-container">
    </div>

    <div id="analytics-results-container">
        <p id="cardCountDisplay" class="filter-count-display">Total Cards: Loading...</p>
        <p class="loading">Loading card data...</p>
    </div>
    </div>

    <script>
        // --- Global State ---
        let allCardsData = [];
        let currentFilteredCards = [];
        let sortDirection = 'asc';
        let lastSortKey = 'card_id'; // Default sort key
        const ABILITY_TEXT_MAX_LENGTH = 70; // Truncation limit for table display
        // --- DOM Elements ---
        // ... (existing elements)
        const exportButton = document.getElementById('exportDataBtn'); // NEW
        const exportOutput = document.getElementById('exportOutput'); // NEW

        // --- DOM Elements ---
        const resultsContainer = document.getElementById('analytics-results-container');
        const typeFilterContainer = document.getElementById('typeFilterContainer');
        const searchInput = document.getElementById('searchInput');
        const clearButton = document.getElementById('clearFiltersBtn');
        const cardCountDisplay = document.getElementById('cardCountDisplay');

        // --- Utility Functions ---
        // (Can remove getPrimaryEffect if no longer used)

        // --- Data Fetching ---
        async function fetchCards() {
            try {
                const response = await fetch('./card.json');
                const data = await response.json();
                allCardsData = data.cards || data;

                populateTypeFilters(allCardsData);
                sortTable(lastSortKey); // initial render
            } catch (error) {
                console.error('Failed to load card data:', error);
                resultsContainer.innerHTML = '<p class="error">Error loading card data. Make sure card.json exists and is valid.</p>';
                if (cardCountDisplay) cardCountDisplay.textContent = 'Total Cards: 0';
            }
        }

        // --- Filter Population ---
        function populateTypeFilters(cards) {
            const uniqueTypes = new Set();
            cards.forEach(card => {
                if (Array.isArray(card.type)) {
                    card.type.forEach(t => uniqueTypes.add(t));
                } else if (typeof card.type === 'string') {
                    card.type.split(/\s*\|\s*|\s+/).forEach(t => {
                        if (t.trim()) uniqueTypes.add(t.trim());
                    });
                }
            });

            typeFilterContainer.innerHTML = '';
            Array.from(uniqueTypes).sort().forEach(type => {
                const button = document.createElement('button');
                button.className = 'type-filter-btn';
                button.textContent = type;
                button.dataset.type = type;
                button.type = 'button';
                button.addEventListener('click', () => {
                    button.classList.toggle('active');
                    filterAndRenderCards();
                });
                typeFilterContainer.appendChild(button);
            });
        }

        // --- Filtering Logic ---
        function filterAndRenderCards() {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const selectedTypes = Array.from(typeFilterContainer.querySelectorAll('.type-filter-btn.active'))
                .map(btn => btn.dataset.type);

            currentFilteredCards = allCardsData.filter(card => {
                const cardTypes = Array.isArray(card.type) ? card.type : (typeof card.type === 'string' ? card.type.split(/\s*\|\s*|\s+/).map(t => t.trim()).filter(t => t) : []);
                let matchesType = selectedTypes.length === 0 || selectedTypes.every(type => cardTypes.includes(type));
                if (!matchesType) return false;

                if (!searchTerm) return true;

                const cardName = card.card_name.toLowerCase();
                const cardId = card.card_id.toLowerCase();
                let abilityText = card.abilities?.level_1?.ability_text?.toLowerCase() || '';
                return cardName.includes(searchTerm) || cardId.includes(searchTerm) || abilityText.includes(searchTerm);
            });

            sortTable(lastSortKey, true);
        }

        // --- Rendering Table ---
        function renderCardsTable(cards) {
            const cardCount = cards.length;
            if (cardCountDisplay) cardCountDisplay.textContent = `Total Cards: ${cardCount}`;
            resultsContainer.innerHTML = '';
            resultsContainer.appendChild(cardCountDisplay);

            if (cardCount === 0) {
                const noResultsMessage = document.createElement('p');
                noResultsMessage.className = 'error';
                noResultsMessage.textContent = 'No cards match the current filters.';
                resultsContainer.appendChild(noResultsMessage);
                return;
            }

            let tableHTML = `
            <table class="analytics-table">
                <thead>
                    <tr>
                        <th></th>
                        <th data-sort-key="card_name" class="${lastSortKey === 'card_name' ? 'sorted-' + sortDirection : ''}">Name</th>
                        <th data-sort-key="card_id" class="${lastSortKey === 'card_id' ? 'sorted-' + sortDirection : ''}">ID</th>
                        <th data-sort-key="rarity" class="${lastSortKey === 'rarity' ? 'sorted-' + sortDirection : ''}">Rarity</th>
                        <th data-sort-key="type" class="${lastSortKey === 'type' ? 'sorted-' + sortDirection : ''}">Types</th>
                        <th data-sort-key="activation_method" class="${lastSortKey === 'activation_method' ? 'sorted-' + sortDirection : ''}">Activation Method</th>
                        <th data-sort-key="ability_text" class="${lastSortKey === 'ability_text' ? 'sorted-' + sortDirection : ''}">L1 Ability Text</th>
                    </tr>
                </thead>
                <tbody>
        `;

            cards.forEach(card => {
                const rarityClass = card.rarity ? `rarity-${card.rarity}` : 'rarity-unknown';
                const typeBadges = Array.isArray(card.type)
                    ? card.type.map(t => `<span class="type-badge type-${t.toLowerCase()}">${t}</span>`).join(' ')
                    : `<span class="type-badge">${card.type || 'N/A'}</span>`;

                const activationMethod = card.activation_method || card.activation?.method || 'N/A';
                let abilityText = card.abilities?.level_1?.ability_text || 'N/A';
                const truncatedAbilityText = abilityText.length > ABILITY_TEXT_MAX_LENGTH
                    ? `${abilityText.substring(0, ABILITY_TEXT_MAX_LENGTH)}...`
                    : abilityText;

                const imageFilename = card.image_filename || 'placeholder.png';
                const imageHTML = `<img src="./cards/${imageFilename}" alt="${card.card_name}" class="card-icon" loading="lazy">`;

                tableHTML += `
                <tr data-card-id="${card.card_id}" title="${abilityText}">
                    <td>${imageHTML}</td>
                    <td>${card.card_name}</td>
                    <td>${card.card_id}</td>
                    <td class="${rarityClass}">${card.rarity || 'N/A'}</td>
                    <td>${typeBadges}</td>
                    <td>${activationMethod}</td>
                    <td>${truncatedAbilityText}</td>
                </tr>
            `;
            });

            tableHTML += '</tbody></table>';
            resultsContainer.insertAdjacentHTML('beforeend', tableHTML);
        }

        // --- Sorting Logic ---
        function sortTable(key, preventDirectionFlip = false) {
            if (lastSortKey === key && !preventDirectionFlip) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else if (lastSortKey !== key) {
                sortDirection = 'asc';
                lastSortKey = key;
            }

            currentFilteredCards.sort((a, b) => {
                let valA, valB;
                if (key === 'ability_text') {
                    valA = (a.abilities?.level_1?.ability_text || '').toLowerCase();
                    valB = (b.abilities?.level_1?.ability_text || '').toLowerCase();
                } else if (key === 'type') {
                    valA = (Array.isArray(a.type) ? a.type.join(' ') : (a.type || '')).toLowerCase();
                    valB = (Array.isArray(b.type) ? b.type.join(' ') : (b.type || '')).toLowerCase();
                } else if (key === 'activation_method') {
                    valA = (a.activation_method || a.activation?.method || '').toLowerCase();
                    valB = (b.activation_method || b.activation?.method || '').toLowerCase();
                } else {
                    valA = (a[key] || '').toString().toLowerCase();
                    valB = (b[key] || '').toString().toLowerCase();
                }

                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            renderCardsTable(currentFilteredCards);
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            fetchCards();

            searchInput.addEventListener('input', filterAndRenderCards);

            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                typeFilterContainer.querySelectorAll('.type-filter-btn.active').forEach(btn => btn.classList.remove('active'));
                filterAndRenderCards();
            });

            resultsContainer.addEventListener('click', function (e) {
                const th = e.target.closest('th');
                if (th && th.dataset.sortKey) {
                    sortTable(th.dataset.sortKey);
                }
            });
            // NEW EXPORT BUTTON LISTENER
            if (exportButton) {
                exportButton.addEventListener('click', exportData);
            }
        });

        // --- New Export Function ---
        function exportData() {
            if (currentFilteredCards.length === 0) {
                alert("No cards are currently filtered to export.");
                return;
            }

            // 1. Format the data for easy reading (Plain Text)
            const formattedText = currentFilteredCards.map(card => {
                const name = card.card_name || 'N/A';
                const id = card.card_id || 'N/A';
                const rarity = card.rarity || 'N/A';
                const types = Array.isArray(card.type) ? card.type.join(', ') : (card.type || 'N/A');
                const activation = card.activation_method || card.activation?.method || 'N/A';

                // **This pulls the FULL, UNTRUNCATED ability text:**
                const fullAbilityText = card.abilities?.level_1?.ability_text || 'N/A';

                // Use a clear, consistent template for the AI
                return `
Card Name: ${name}
Card ID: ${id}
Rarity: ${rarity}
Types: ${types}
Activation: ${activation}
Ability Text (L1): ${fullAbilityText}
-------------------------------------`;
            }).join('\n'); // Join all card strings

            // 2. Display the formatted text in the textarea
            exportOutput.value = formattedText;
            exportOutput.style.display = 'block'; // Make the textarea visible
            exportOutput.select(); // Select the text

            // Optional: Copy to clipboard (modern browsers only)
            try {
                document.execCommand('copy');
                alert('Filtered card data copied to clipboard! Ready to paste into the AI.');
            } catch (err) {
                // Fallback message if automatic copy fails
                alert('Filtered data is ready below. Press Ctrl+C (Cmd+C) to copy the text.');
            }
        }
    </script>

</body>

</html>
