<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Combiner</title>
    <link rel="stylesheet" href="styles.css"> 
    
    <style>
        #card-combiner-container {
            font-family: sans-serif;
            text-align: center;
            padding: 20px;
        }

        #cc-canvas {
            border: 1px solid #aaa;
            margin-top: 20px;
            cursor: grab;
            /* Make canvas fill container width on mobile */
            max-width: 100%; 
            height: auto;
        }

        #card-combiner-container input,
        #card-combiner-container button,
        #card-combiner-container select {
            margin: 5px;
        }

        #card-combiner-container button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #card-combiner-container button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }
    </style>
</head>

<body>
    <div id="card-combiner-container">
        <h1>Card Combiner</h1>
        <a href="cards-index.html" class="btn">‚Üê Back to Cards</a>
        <br><br>

        <label>Card Name:
            <input type="text" id="cc-cardName" placeholder="e.g. chicken_soup">
        </label>
        <br><br>

        <input type="file" id="cc-aiArt" accept="image/*"><br><br>

        <select id="cc-templateSelect">
            <option value="Cardtemp/comTemp.png">Common</option>
            <option value="Cardtemp/ucomTemp.png">Uncommon</option>
            <option value="Cardtemp/rareTemp.png">Rare</option>
            <option value="Cardtemp/epicTemp.png">Epic</option>
            <option value="Cardtemp/ultTemp.png">Ultimate</option>
        </select>
        <br><br>

        <button id="cc-downloadBtn">Download PNG</button>
        <br>
        
        <canvas id="cc-canvas" width="411" height="617"></canvas> 
    </div>

    <script>
        (function () {
            const canvas = document.getElementById("cc-canvas");
            const ctx = canvas.getContext("2d");

            let template = new Image();
            let aiImage = null;
            let scale = 1, offsetX = 0, offsetY = 0;
            let dragging = false, lastX, lastY;
            let initialPinchDistance = null; // For touch zoom

            const templateSelect = document.getElementById("cc-templateSelect");
            templateSelect.onchange = loadTemplate;

            function loadTemplate() {
                template = new Image();
                template.onload = () => {
                    redraw();
                };
                template.src = templateSelect.value;
            }
            loadTemplate();

            document.getElementById("cc-aiArt").onchange = e => {
                const reader = new FileReader();
                reader.onload = ev => {
                    aiImage = new Image();
                    aiImage.onload = () => {
                        // Reset transforms when new image is loaded
                        scale = 1;
                        offsetX = offsetY = 0;
                        redraw();
                    };
                    aiImage.src = ev.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            };

            function redraw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (aiImage) {
                    const templateOriginalWidth = 411; 
                    const templateOriginalHeight = 617; 
                    
                    // Template hole parameters (based on your template's aspect ratio)
                    // These are scaled to fit the actual canvas size
                    const holeX = 86;
                    const holeY = 42;
                    const holeWidth = 237; 
                    const holeHeight = 237; 

                    // Your previous logic used a hole size relative to a 262x394 scale, 
                    // which is inconsistent with the canvas width/height of 411x617.
                    // Let's use the actual canvas size for scaling:
                    const holePixelX = holeX * (canvas.width / templateOriginalWidth);
                    const holePixelY = holeY * (canvas.height / templateOriginalHeight);
                    const holePixelSize = holeWidth * (canvas.width / templateOriginalWidth); // Assuming square hole

                    // Draw the image first (background layer)
                    // We only use the center portion of the AI image to start
                    ctx.drawImage(
                        aiImage,
                        0, 0, // Source X, Y (Start drawing from the image's top-left)
                        aiImage.width, aiImage.height, // Source Width, Height (Use the whole image)
                        holePixelX + offsetX, // Destination X (Offset by drag)
                        holePixelY + offsetY, // Destination Y (Offset by drag)
                        holePixelSize * scale, // Destination Width (Scaled by zoom)
                        holePixelSize * scale // Destination Height (Scaled by zoom)
                    );
                }

                // Draw the template overlay (foreground layer)
                if (template) {
                    ctx.drawImage(template, 0, 0, canvas.width, canvas.height);
                }
            }
            
            // --- Coordinate Helper ---
            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                // Check if it's a touch event or a mouse event
                const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top,
                };
            }

            // --- MOUSE (Desktop) Events for Dragging and Zoom ---
            canvas.addEventListener("mousedown", e => {
                dragging = true;
                const coords = getCanvasCoordinates(e);
                lastX = coords.x;
                lastY = coords.y;
            });
            canvas.addEventListener("mousemove", e => {
                if (dragging && aiImage) {
                    const coords = getCanvasCoordinates(e);
                    // Scale the movement by the ratio of canvas CSS size to its actual pixel size
                    const scaleFactor = canvas.width / canvas.offsetWidth; 

                    offsetX += (coords.x - lastX) * scaleFactor;
                    offsetY += (coords.y - lastY) * scaleFactor;
                    
                    lastX = coords.x;
                    lastY = coords.y;
                    redraw();
                }
            });
            canvas.addEventListener("mouseup", () => dragging = false);
            canvas.addEventListener("mouseleave", () => dragging = false);
            
            // Mouse Wheel Zoom
            canvas.addEventListener("wheel", e => {
                if (aiImage) {
                    e.preventDefault();
                    // Zoom towards the mouse cursor
                    const delta = e.deltaY < 0 ? 1.05 : 0.95;
                    scale *= delta;
                    redraw();
                }
            });


            // --- TOUCH (Mobile) Events for Panning and Zoom ---
            canvas.addEventListener("touchstart", e => {
                if (!aiImage) return;

                if (e.touches.length === 1) {
                    // Start dragging (Pan)
                    dragging = true;
                    const coords = getCanvasCoordinates(e);
                    lastX = coords.x;
                    lastY = coords.y;
                    initialPinchDistance = null; // Reset pinch detection
                } else if (e.touches.length === 2) {
                    // Start pinch zoom
                    dragging = false; // Disable dragging when pinching
                    initialPinchDistance = getPinchDistance(e);
                }
            }, { passive: false });

            canvas.addEventListener("touchmove", e => {
                if (!aiImage) return;
                e.preventDefault(); // Prevent scrolling the page

                const scaleFactor = canvas.width / canvas.offsetWidth; 
                
                if (e.touches.length === 1 && dragging) {
                    // Panning
                    const coords = getCanvasCoordinates(e);
                    offsetX += (coords.x - lastX) * scaleFactor;
                    offsetY += (coords.y - lastY) * scaleFactor;
                    lastX = coords.x;
                    lastY = coords.y;
                    redraw();
                } else if (e.touches.length === 2) {
                    // Pinch Zooming
                    const currentDistance = getPinchDistance(e);
                    if (initialPinchDistance !== null && currentDistance !== 0) {
                        const zoomFactor = currentDistance / initialPinchDistance;
                        scale *= zoomFactor;
                        initialPinchDistance = currentDistance; // Update for continuous pinch
                        redraw();
                    }
                }
            }, { passive: false }); // Need passive: false to allow e.preventDefault()

            canvas.addEventListener("touchend", e => {
                dragging = false;
                initialPinchDistance = null;
            });
            
            // Helper function to calculate distance between two touches
            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.sqrt(
                    (t2.clientX - t1.clientX) ** 2 + (t2.clientY - t1.clientY) ** 2
                );
            }

            // --- Download (Unchanged) ---
            document.getElementById("cc-downloadBtn").addEventListener("click", () => {
                const name = document.getElementById("cc-cardName").value || "card";
                const link = document.createElement("a");
                link.download = name + ".png";
                link.href = canvas.toDataURL("image/png");
                link.click();
            });

        })();
    </script>

</body>
</html>